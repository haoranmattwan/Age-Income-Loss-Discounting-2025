---
title: "Replication Code: Age, Income, and the Discounting of Delayed Monetary Losses"
author: "Haoran (Matt) Wan"
date: "today"
format: 
  html:
    toc: true
    code-fold: false
    self-contained: true
    theme: cosmo
    mainfont: "Garamond"
engine: knitr
---

## Introduction

This document contains the complete R code to replicate the analyses from the publication:

> Wan, H., Myerson, J., Green, L., Strube, M. J., & Hale, S. (2025). Age, income, and the discounting of delayed monetary losses. *The Journals of Gerontology, Series B: Psychological Sciences and Social Sciences, 80*(11), gbaf162. [https://doi.org/10.1093/geronb/gbaf162](https://doi.org/10.1093/geronb/gbaf162)

The analyses examine how **age** and **income** influence the discounting of delayed monetary losses. The primary measure of discounting is the **Area under the Curve (AuC)**, which is modeled using a series of **Bayesian multilevel beta regressions**.

The workflow is organized as follows:

1.  **Setup**: Loads all necessary packages and custom functions.
2.  **Data Processing**: Cleans and prepares the raw data for analysis.
3.  **Power Analysis**: Runs a simulation to confirm adequate statistical power.
4.  **Descriptive & Correlational Analyses**: Replicates descriptive statistics, visualizations, and correlation tables from the paper.
5.  **Hypothesis Testing**: Fits the main Bayesian models reported in Table 3 of the paper.
6.  **Supplementary Analyses**: Fits additional models testing the roles of depression and psychological distress.
7.  **Interaction Plots**: Generates visualizations for the key interactions reported in Figure 4 of the paper.

The data for this study are available in the Supplementary Material at the publisher's website.

```{r setup_package}
#| message: false
#| warning: false

# --- 1. SETUP: PACKAGES, OPTIONS, AND FUNCTIONS ---

# Set global chunk options to suppress messages and warnings for a clean output
knitr::opts_chunk$set(message = FALSE, warning = FALSE, error = FALSE)

# --- Load All Packages ---
# The following packages are required to run the script.
library(brms)         # For Bayesian multilevel modeling
library(cmdstanr)     # Backend for brms, for faster model fitting
library(glmmTMB)      # For frequentist mixed-effects models (used in power analysis)
library(tidybayes)    # For processing and visualizing Bayesian model posteriors
library(psych)        # For reliability analysis (Cronbach's Alpha)
library(Hmisc)        # For correlation matrices with p-values
library(multcomp)     # For post-hoc comparisons (e.g., amount effect)
library(minpack.lm)   # For non-linear least squares fitting (hyperboloid model)
library(doSNOW)       # For parallel processing during power simulation
library(here)         # For reproducible file paths
library(modelr)       # For creating model-based data grids
library(ggpubr)       # For arranging ggplot objects
library(tidyverse)    # For data manipulation and visualization (ggplot2, dplyr, etc.)
library(bayestestR)   # For calculating probability of direction (pd)

# --- Custom Functions ---

#' Custom ggplot2 Theme for Publication-Ready Plots
#'
#' @description A standardized theme for consistent plot aesthetics.
#' @return A ggplot theme object.
mattheme <- theme(
  text = element_text(size = 12, family = "Arial", color = "black", face = "bold"), 
  axis.text.y = element_text(colour = "black", size = 10, face = "bold"), 
  axis.text.x = element_text(colour = "black", size = 10, face = "bold", angle = 0), 
  axis.title.x = element_text(margin = margin(7, 0, 0, 0), size = 14), 
  axis.title.y = element_text(margin = margin(0, 7, 0, 0), size = 14), 
  plot.title = element_text(size = 14, face = "bold", hjust = 0.5), 
  panel.background = element_rect(fill = "white", linetype = 1, color = "black", size = 1), 
  panel.grid = element_blank(),
  strip.background = element_blank(),
  strip.text = element_text(size=10),
  legend.key = element_blank()
)

#' Area Under the Curve (AuC) Calculation
#'
#' @description Calculates the area under the curve using the trapezoidal rule.
#' @param x A numeric vector of x-coordinates (e.g., normalized delays).
#' @param y A numeric vector of y-coordinates (e.g., subjective values).
#' @return The calculated area as a single numeric value.
auc <- function(x, y) {
  sum(diff(x) * (y[-1] + y[-length(y)])) / 2
}

#' Wrapper for brms Beta Regression Models
#'
#' @description A standardized function for fitting Bayesian beta regression models.
#' @param Formula The brms formula for the model.
#' @param Data The dataframe containing the variables in the formula.
#' @param File Optional path to save the fitted model object, enabling caching.
#' @return A fitted brms model object.
betaMLM_brm <- function(Formula, Data, File = NULL) {
  brm(formula = Formula, 
      family = Beta(), data = Data, 
      # Set weakly informative priors as described in the paper
      prior = c(prior(normal(0, 100^100), class = Intercept), 
                prior(cauchy(0, 2.5), class = b),
                prior(cauchy(0, 2.5), class = sd),
                prior(normal(0, 100^100), class = phi)),
      iter = 4000, warmup = 2000, chains = 4, cores = 4, refresh = 0,
      backend = "cmdstanr", # Use cmdstanr for performance
      control = list(adapt_delta=0.95, max_treedepth=10), 
      file = File) # Caches the model fit to the specified file
}

#' Custom Summary Function for brms Models
#'
#' @description Formats brms model output to match publication tables.
#' @param brm_model A fitted brms model object.
#' @param rownames Optional vector of strings to rename the model parameters.
#' @return A formatted dataframe with posterior medians, standard deviations, and probability of direction (pd).
brm_summary <- function(brm_model, rownames = NULL) {
  suppressWarnings(trans_brms <- brm_model |>
                     gather_draws(`b_.*`, regex = TRUE) |> 
                     select(.variable, .value) |>
                     group_by(.variable) |> 
                     # Calculate probability of direction (pd)
                     mutate(pd = ecdf(.value)(0),
                            pd = ifelse(pd >= .5, pd, 1 - pd)) |> 
                     group_by(.variable, pd) |>
                     # Summarize posteriors: median and sd
                     summarise(SE = sd(.value), .value = median(.value), .groups = 'drop') |>
                     select(.variable, .value, SE, pd) |>
                     # Formatting steps to create a clean table
                     mutate(.variable = factor(.variable, levels = as.data.frame(p_direction(brm_model))$Parameter)) |>
                     arrange(.variable) |>
                     mutate(across(.cols = -.variable, ~sprintf("%.3f", round(., 3)))) |>
                     mutate(across(c(.value, SE, pd), ~str_replace(., "0.", "."))) |>
                     mutate(pd = str_replace(pd, "1.000", ">.999")) |>
                     mutate(.variable = str_remove_all(.variable, "b_|_std|_c")) |>
                     mutate(SE = paste0("(", SE, ")")) |>
                     rename(Variable = .variable, "Est." = .value) |>
                     unite("Est.(SE)", "Est.", "SE", sep = " ") |>
                     column_to_rownames("Variable"))
  
  if (!is.null(rownames)) {
    rownames(trans_brms) <- rownames
  }
  
  return(as.data.frame(trans_brms))
}

#' Power Analysis Simulation Function
#'
#' @description Simulates data and runs models to estimate statistical power.
#' @param n_ID Number of participants per decade.
#' @param beta1 Assumed effect size for Age.
#' @param beta2 Assumed effect size for Income.
#' @param phi Precision parameter for the beta distribution.
#' @param sigma Standard deviation of the random intercept.
#' @param n_sim Number of simulations to run.
#' @return A numeric vector of power estimates for four different model parameters.
SimPower_MLM <- function(n_ID, beta0 = 0, beta1, beta2, phi = 12.2, sigma = .944, n_sim) {
  # Set up parallel processing cluster
  cl <- makeCluster(4)
  registerDoSNOW(cl)
  pb <- txtProgressBar(min = 0, max = n_sim, style = 3)
  progress <- function(n) setTxtProgressBar(pb, n)
  opts <- list(progress = progress)
  
  # Run simulations in parallel
  sim_results <- foreach(i=(1:n_sim), .combine=rbind, .packages = c("glmmTMB","tidyverse"), .options.snow = opts) %dopar% {
    # --- Data generation for one simulation ---
    group_ids <- rep(seq_len(n_ID*6), each = 3)
    Age <- rep(c(runif(n_ID,20,29),runif(n_ID,30,39),runif(n_ID,40,49),
                 runif(n_ID,50,59),runif(n_ID,60,69),runif(n_ID,70,80)), each = 3)
    Income <- rep(rbinom(n_ID*6,4,.5), each = 3) + 1
    eta <- numeric(n_ID*3*6)
    b <- rnorm(n_ID*6, mean = 0, sd = sigma) # Random intercepts
    # Construct linear predictor
    for (g in seq_len(n_ID * 6)) {
      idx <- which(group_ids == g)
      eta[idx] <- beta0+b[g] + (beta1/(2*sd(Age)))*Age[idx] + (beta2/(2*sd(Income)))*Income[idx]
    }
    mu <- plogis(eta) # Inverse logit to get mean for beta distribution
    AuC <- rbeta(n_ID*3*6, mu * phi, (1 - mu) * phi) # Sample AuC from beta distribution
    AuC[AuC == 1] <- 1 - .Machine$double.eps # Adjust 1s for beta regression
    
    # --- Fit models to simulated data ---
    sim_dat <- data.frame(ID = factor(group_ids), Age = Age, Income = Income, AuC = AuC)
    SimDat20_80 <- mutate(sim_dat, Age_std = (Age - mean(Age)) / (2*sd(Age)))
    SimDat35_80 <- mutate(filter(sim_dat, Age >= 35),
                          Age_std = (Age - mean(Age)) / (2*sd(Age)),
                          Income_std = (Income - mean(Income)) / (2*sd(Income)))
    
    # Use tryCatch to handle model convergence failures
    tryCatch({
      fit1 <- glmmTMB(AuC ~ 1 + Age_std + (1 | ID), family = beta_family(), data = SimDat20_80)
      fit2 <- glmmTMB(AuC ~ 1 + Age_std + Income_std + (1 | ID), family = beta_family(), data = SimDat35_80)
      c(summary(fit1)$coefficients$cond["Age_std","Pr(>|z|)"], 
        summary(fit2)$coefficients$cond["Age_std","Pr(>|z|)"],
        summary(fit2)$coefficients$cond["Income_std","Pr(>|z|)"])
    }, error = function(e) {c(NA,NA,NA)})
  }
  close(pb)
  stopCluster(cl) # Stop the cluster
  
  # Calculate power as the proportion of significant p-values
  c(mean(sim_results[,1] < 0.05, na.rm = TRUE),
    mean(sim_results[,2] < 0.05, na.rm = TRUE),
    mean(sim_results[,3] < 0.05, na.rm = TRUE))
}
```

## Data Loading and Processing

The raw dataset is loaded and undergoes several processing steps to prepare for analysis. This includes filtering to the final sample (N = 594), renaming variables for clarity, calculating individual-level AuC values, and creating scaled predictor variables for the regression models.

```{r setup_data}
#| message: false
#| warning: false

# --- 2. DATA LOADING AND PROCESSING ---

# Load the raw data from the .csv file
# The original dataset contains data from multiple studies.
setwd(here::here())
Samp <- read_csv("R code/dat/Lifespan.csv") |> select(-1)

# --- Initial Filtering and Cleaning ---
# This chain filters the data to the final sample used in the paper.
Disc_Raw <- filter(Samp, type == "delay" & task == "loss") |>
  # Filter by age, attention check pass (check == 6), and valid gender entry
  filter(!is.na(age), age >= 20, age <= 80, check == 6, !is.na(sex)) |>
  # Remove participants with inconsistent age reporting
  filter(age-10*age_grp >= 0 & age-10*age_grp <= 10) |>
  # Create age group factor for plotting and descriptive stats
  mutate(age_grp_factor = factor(case_when(
                                  age >= 20 & age < 35 ~ "20-34",
                                  age >= 35 & age <= 50 ~ "35-50",
                                  age > 50 & age < 65 ~ "51-64",
                                  age >= 65 & age <= 80 ~ "65-80"), 
                                levels = c("20-34","35-50","51-64","65-80"))) |>
  # Select and rename variables for clarity
  select(-c(task,month,year,white,hislat,duration,check, age_grp)) |>
  rename(Exp = type, ID = id, Amount = amt, Delay = iv, SV = value, Age = age, 
         Income = income, Gender = sex, Depression = depress, Anxiety = anxious, 
         Distress = hads, Education = edu, Health = health, Age_Group = age_grp_factor, 
         Ethnicity = eth, Race = race)

# --- Create Group-Level Data Frame for Plotting (Figure 1) ---
Disc_Grp <- Disc_Raw |>
  mutate(Amount = factor(if_else(Amount==1, "$150", if_else(Amount==3, "$30,000", "$2,500")), 
                         levels = c("$150", "$2,500", "$30,000"))) |>
  group_by(Age_Group, Amount, Delay) |> 
  summarise(Mean_SV = mean(SV), .groups = 'drop')

# --- Create Individual-Level Data Frame ---
Disc_ID <- Disc_Raw |>
  # Convert education from categorical to years
  mutate(Education = case_when(Education == 1 ~ 5, Education == 2 ~ 12, Education == 3 ~ 14,  
                               Education == 4 ~ 16, Education == 5 ~ 18),
         # Log-transform amount due to skewed distribution
         Amount_log = log(if_else(Amount==1, 150, if_else(Amount==3, 30000, 2500))))

# --- Calculate Area under the Curve (AuC) for Each Participant ---
# AuC is calculated for each of the three loss amounts.
AuC_ID <- Disc_ID |>
  group_by(ID, Amount) |>
  # Normalize delay to a 0-1 scale for AuC calculation
  summarise(AuC = auc(Delay/max(Delay), SV), .groups = 'drop') |>
  # Join back the unique demographic info for each participant
  left_join(distinct(Disc_ID, ID, Age, Age_Group, Income, Gender, Education, 
                     Distress, Anxiety, Depression, Health), by = "ID") |>
  # Adjust AuC values of 1 to be slightly less than 1, as required by beta regression
  mutate(AuC = if_else(AuC == 1, 1 - .Machine$double.eps, AuC))

# --- Create Model-Specific Dataframes with Scaled/Centered Predictors ---
# Predictors are scaled by dividing by 2 standard deviations, as recommended by Gelman (2008).
# This puts them on a comparable scale and makes coefficients more interpretable.
DL_dat1 <- filter(AuC_ID, Age >= 35) |> mutate(Age_std = (Age - mean(Age)) / (2*sd(Age)))

DL_dat2 <- filter(AuC_ID, Age >= 35, !is.na(Income)) |>
  mutate(Age_std = (Age - mean(Age)) / (2*sd(Age)),
         Income_std = (Income - mean(Income)) / (2*sd(Income)))

DL_dat3 <- filter(AuC_ID, Age >= 35, !is.na(Income), !is.na(Distress)) |>
  mutate(Age_std = (Age - mean(Age)) / (2*sd(Age)),
         Income_std = (Income - mean(Income)) / (2*sd(Income)),
         Anxiety_std = (Anxiety - mean(Anxiety)) / (2*sd(Anxiety)),
         Depression_std = (Depression - mean(Depression)) / (2*sd(Depression)),
         Distress_std = (Distress - mean(Distress)) / (2*sd(Distress)))

# Data for the full model (Model 4)
DL_dat4 <- filter(AuC_ID, Age >= 35, !is.na(Income), !is.na(Gender), 
                  !is.na(Education), !is.na(Distress), !is.na(Health)) |>
  mutate(Age_std = (Age - mean(Age)) / (2*sd(Age)),
         Amount_std = (Amount - mean(Amount)) / (2*sd(Amount)),
         Income_std = (Income - mean(Income)) / (2*sd(Income)),
         Gender_c = Gender - mean(Gender), # Center binary predictor
         Education_std = (Education - mean(Education)) / (2*sd(Education)),
         Anxiety_std = (Anxiety - mean(Anxiety)) / (2*sd(Anxiety)),
         Depression_std = (Depression - mean(Depression)) / (2*sd(Depression)),
         Distress_std = (Distress - mean(Distress)) / (2*sd(Distress)),
         Health_std = (Health - mean(Health)) / (2*sd(Health)))

cat("Data processing complete. Final sample size: ", n_distinct(AuC_ID$ID), " participants.\n")
```

## Power Analysis

A simulation-based power analysis was conducted to ensure the sample size (N â‰ˆ 100 per decade) was sufficient to detect hypothesized small-to-medium effects of Age and Income (parameterized as `log(1.5)`) with at least 80% power. The results confirm that the study was well-powered.

```{r power_analysis}
#| message: false
#| warning: false
#| eval: false

# --- 3. POWER ANALYSIS ---

# The power analysis is computationally intensive. We use caching to avoid
# re-running it every time the document is rendered.
# If "power.rds" exists, load it; otherwise, run the simulation and save the results.
if (file.exists("rds/power.rds")) {
  pow_est <- readRDS("rds/power.rds")
} else {
  # Run 5000 simulations with n=100 participants per decade.
  pow_est <- SimPower_MLM(n_ID = 100, beta1 = log(1.5), beta2 = log(1.5), n_sim = 10)
  saveRDS(pow_est, file = "rds/power.rds")
}

# Display the power estimates in a clean table
data.frame(
    Coefficient = c("Age (Full Sample: 20-80)", "Age (Restricted Sample: 35-80)", "Income (Restricted Sample: 35-80)"),
    Power = sprintf("%.2f%%", pow_est * 100)
  )
```

## Descriptive & Correlational Analyses

This section replicates the descriptive results from the paper. It includes the visualization of group-level discounting functions (Figure 1), goodness-of-fit statistics for the hyperboloid model, reliability of the AuC measure, and the correlation matrices for key variables.

```{r descriptive_analyses}
#| message: false
#| warning: false

# --- 4. DESCRIPTIVE & CORRELATIONAL ANALYSES ---

# --- Figure 1 Replication: Group-Level Discounting Functions ---
# This plot shows the mean relative subjective value as a function of delay,
# broken down by age group and the amount of the delayed loss.
Disc_Grp |>
  arrange(desc(Amount)) |>
  ggplot(aes(Delay, Mean_SV, shape = Amount, fill = Amount, color = Amount, linetype = Amount)) +
  # Fit a hyperboloid discounting function to the group means
  geom_smooth(method = "nlsLM", formula = y ~ 1 / (1 + exp(k)*x)^b,
              method.args = list(start = list(k = -4, b = .5)),
              se = FALSE, size = .7, show.legend = FALSE) +
  geom_point(size = 3, stroke = .5, color = "black") +
  scale_y_continuous(limits = c(-.005, 1.005), breaks=seq(0,1,by=0.2), expand=c(0,0)) +
  scale_x_continuous(limits = c(-10, 130), expand=c(0,0)) +
  facet_wrap(~Age_Group, nrow = 1) +
  scale_linetype_manual(values = c("dotted", "dashed", "solid")) +  
  scale_fill_manual(name = "Amount", values = c("$30,000"="#1f78b4","$2,500"= "#ff7f00","$150"="#33a02c")) +
  scale_color_manual(name = "Amount", values = c("$30,000"="#1f78b4","$2,500"= "#ff7f00","$150"="#33a02c")) +
  scale_shape_manual(name="Amount", values = c("$150" = 22, "$2,500" = 24, "$30,000" = 21)) + 
  labs(x = "Delay (months)", y = "Relative Subjective Value") +
  theme_bw() + mattheme

# --- Goodness-of-Fit for Group-Level Hyperboloid Functions ---
# The hyperboloid model provided a good fit to the data across all groups.
cat("--- R-squared for Group-Level Hyperboloid Fits ---\n")
Disc_Grp |>
  group_by(Age_Group, Amount) |>
  reframe(R2 = rsquare(nlsLM(Mean_SV ~ 1 / (1 + k * Delay)^s, 
                             data = pick(everything()), start = list(k = .1, s = 1)), 
                       data = pick(everything()))) |>
  pivot_wider(names_from = Age_Group, values_from = R2) |> 
  print(digits = 4)

# --- Test for the "Amount Effect" ---
# Test whether discounting rates differ across the three loss amounts.
# A significant effect was found for younger, but not older, groups.
cat("\n--- P-values for Amount Effect within each Age Group ---\n")
AuC_ID |>
  group_by(Age_Group) |>
  reframe(p_val = summary(glht(
    glmmTMB(AuC ~ as.factor(Amount) + (1|ID), data = pick(everything()), family = beta_family()), 
    linfct = matrix(c(-1, 1, 0), nrow = 1)))$test$pvalues[1]
  ) |>
  pivot_wider(names_from = Age_Group, values_from = p_val) |>
  print(digits = 4)
  
# --- Reliability of AuC Measure (Cronbach's Alpha) ---
cat("\n--- Reliability of AuC Measure (Cronbach's Alpha) ---\n")
reliability_df <- pivot_wider(AuC_ID[,c("ID", "Amount", "AuC")], names_from = Amount, values_from = AuC)
print(psych::alpha(reliability_df[,-1]))

# --- Correlation Matrix for Participants Aged 20-80 (Supplementary Table 1) ---
cat("\n--- Correlation Matrix for All Participants (Aged 20-80) ---\n")
Cor_df_full <- AuC_ID |>
  group_by(ID) |>
  summarise(across(c(Age, Income, Education, Gender, Distress, Anxiety, Depression, Health, AuC), mean, na.rm=TRUE)) |>
  ungroup() |>
  select(Age, Income, Education, Gender, Distress, Anxiety, Depression, Health, AuC)
corr_matrix_full <- rcorr(as.matrix(Cor_df_full))
print(round(corr_matrix_full$r, 3))


# --- Correlation Matrix for Participants Aged 35-80 (Table 2 Replication) ---
cat("\n--- Correlation Matrix for Participants Aged 35-80 (Table 2) ---\n")
Cor_df_35plus <- AuC_ID |>
  filter(Age >= 35) |>
  group_by(ID) |>
  summarise(across(c(Age, Income, Education, Gender, Distress, Anxiety, Depression, Health, AuC), mean, na.rm=TRUE)) |>
  ungroup() |>
  select(Age, Income, Education, Gender, Distress, Anxiety, Depression, Health, AuC)
corr_matrix_35plus <- rcorr(as.matrix(Cor_df_35plus))
print(round(corr_matrix_35plus$r, 3))
```

## Hypothesis Testing: Bayesian Multilevel Models

This section replicates the main hypothesis tests from the paper, corresponding to Table 3. A series of four Bayesian multilevel beta regression models were fitted to test the effects of age, income, anxiety, and other covariates on AuC for participants aged 35 and older.

```{r hypothesis_test}
#| message: false
#| warning: false

# --- 5. HYPOTHESIS TESTING: BAYESIAN MULTILEVEL MODELS ---
# Models are cached to .rds files to avoid re-fitting, which can be time-consuming.
setwd(here::here())

# --- Model 1: AuC ~ Age + Age^2 ---
# This model tests for a linear and quadratic effect of age on discounting.
# The significant quadratic term indicates the effect of age diminishes in older participants.
cat("--- Model 1: AuC ~ Age + Age^2 ---\n")
DL_mod1b <- betaMLM_brm(Formula = bf(AuC ~ Age_std + I(Age_std^2) + (1 | ID)), 
                        Data = DL_dat1, File = "R code/07-28-25/brm/DL_mod1b")
print(brm_summary(DL_mod1b))

# --- Model 2: AuC ~ Age + Age^2 + Income ---
# Adds income as a predictor. Higher income was associated with shallower discounting (larger AuC)].
cat("\n--- Model 2: AuC ~ Age + Age^2 + Income ---\n")
DL_mod2 <- betaMLM_brm(Formula = bf(AuC ~ Age_std + I(Age_std^2) + Income_std + (1|ID)), 
                       Data = DL_dat2, File = "R code/07-28-25/brm/DL_mod2")
print(brm_summary(DL_mod2))

# --- Model 3: AuC ~ Age + Age^2 + Income + Anxiety ---
# Adds anxiety as a predictor. Anxiety was significant in this model.
cat("\n--- Model 3: AuC ~ Age + Age^2 + Income + Anxiety ---\n")
DL_mod3 <- betaMLM_brm(Formula = bf(AuC ~ Age_std + I(Age_std^2) + Income_std + Anxiety_std + (1|ID)), 
                       Data = DL_dat3, File = "R code/07-28-25/brm/DL_mod3")
print(brm_summary(DL_mod3))

# --- Model 4: Full Model with Covariates and Interactions ---
# The full model includes all covariates and their interactions with age.
cat("\n--- Model 4: Full Model with Covariates and Interactions ---\n")
DL_mod4 <- betaMLM_brm(
  Formula = bf(AuC ~ (Age_std+Income_std + Anxiety_std + Amount_std + Education_std + Gender_c + Health_std)^2 + I(Age_std^2) + (1 + Amount_std|ID)), 
  Data = DL_dat4, File = "R code/07-28-25/brm/DL_mod4"
)
print(brm_summary(DL_mod4))
```

## Supplementary Analyses: Depression and Distress Models

The paper notes that while anxiety was a significant predictor of discounting, depression and overall psychological distress were not (when controlling for age and income). This section presents the models that confirm these findings.

```{r supplementary_analyses}
#| message: false
#| warning: false

# --- 6. SUPPLEMENTARY ANALYSES: DEPRESSION & DISTRESS ---
setwd(here::here())

# --- Model S1: Test effect of Depression ---
cat("--- Model S1: AuC ~ Age + Age^2 + Income + Depression ---\n")
DL_modS1 <- betaMLM_brm(Formula = bf(AuC ~ Age_std + I(Age_std^2) + Income_std + Depression_std + (1|ID)), 
                        Data = DL_dat3, File = "R code/07-28-25/brm/DL_modS1")
print(brm_summary(DL_modS1))

# --- Model S2: Full model with Depression ---
cat("\n--- Model S2: Full Model with Depression and Interactions ---\n")
DL_modS2 <- betaMLM_brm(
  Formula = bf(AuC ~ (Age_std + Income_std + Depression_std + Amount_std + Education_std + Gender_c + Health_std)^2 + I(Age_std^2) + (1 + Amount_std|ID)), 
  Data = DL_dat4, File = "R code/07-28-25/brm/DL_modS2"
)
print(brm_summary(DL_modS2))


# --- Model S3: Test effect of Distress ---
cat("\n--- Model S3: AuC ~ Age + Age^2 + Income + Distress ---\n")
DL_modS3 <- betaMLM_brm(Formula = bf(AuC ~ Age_std + I(Age_std^2) + Income_std + Distress_std + (1|ID)), 
                        Data = DL_dat3, File = "R code/07-28-25/brm/DL_modS3")
print(brm_summary(DL_modS3))

# --- Model S4: Full model with Distress ---
cat("\n--- Model S4: Full Model with Distress and Interactions ---\n")
DL_modS4 <- betaMLM_brm(
  Formula = bf(AuC ~ (Age_std + Income_std + Distress_std + Amount_std + Education_std + Gender_c + Health_std)^2 + I(Age_std^2) + (1+Amount_std|ID)),
  Data = DL_dat4, File = "R code/07-28-25/brm/DL_modS4"
)
print(brm_summary(DL_modS4))
```

## Visualizing Key Interactions

This section replicates Figure 4 from the paper, visualizing the key findings from the full regression model (Model 4). The plots show the predicted AuC as a function of age, moderated by income level (left panel) and the magnitude of the loss (right panel). A significant Age x Amount interaction was found, where age differences were more pronounced for larger loss amounts.

```{r model_visualization}
#| message: false
#| warning: false

# --- 7. VISUALIZING KEY INTERACTIONS (FIGURE 4 REPLICATION) ---

# --- Age x Income Interaction Plot ---
# This plot visualizes how the relationship between age and discounting (AuC)
# differs across low, medium, and high income groups.

# 1. Create a grid of predictor values to generate predictions for.
pred_grid_income <- expand(DL_dat4, Age = seq(35, 80, 1),
                           Income = c("<$50K","$50-80K",">$80K")) |>
  # 2. Scale Age and create mock variables for other predictors, holding them at their mean (0).
  mutate(Age_std = (Age - mean(DL_dat4$Age)) / (2*sd(DL_dat4$Age)),
         Income_std = case_when(Income == "<$50K" ~ (1.5 - mean(DL_dat4$Income)) / (2*sd(DL_dat4$Income)),
                                Income == "$50-80K" ~ (3 - mean(DL_dat4$Income)) / (2*sd(DL_dat4$Income)),
                                Income == ">$80K" ~ (4.5 - mean(DL_dat4$Income)) / (2*sd(DL_dat4$Income))),
         Amount_std = 0, Education_std = 0, Gender_c = 0, 
         Anxiety_std = 0, Health_std = 0,
         Income = factor(Income, levels = c(">$80K","$50-80K","<$50K")))

# 3. Generate posterior predictions from the model using the grid.
p_income <- add_epred_draws(DL_mod4, newdata = pred_grid_income, re_formula = NA) |>
  # 4. Summarize the posterior draws to get the median predicted AuC for each point.
  group_by(Age, Income) |> 
  summarize(.epred = median(.epred), .groups = 'drop') |>
  # 5. Build the ggplot object.
  ggplot(aes(x = Age, y = .epred, fill = Income, color = Income)) +
  geom_line(aes(linetype = Income), size = 1) +
  labs(x = "Age", y = "Area under the Curve", color = "Income", fill = "Income", linetype = "Income") + 
  scale_y_continuous(limits = c(.198, 1.002), breaks = seq(.2,1,.2), expand = c(0,0)) +
  scale_x_continuous(limits = c(33.5,81.5), breaks = seq(35,80,15), expand = c(0,1)) +
  scale_color_manual(values = c(">$80K"="#b15928","$50-80K"="#6a3d9a","<$50K"="#e31a1c")) +
  scale_fill_manual(values = c(">$80K"="#b15928","$50-80K"="#6a3d9a","<$50K"="#e31a1c")) +
  scale_linetype_manual(values = c(">$80K"="solid","$50-80K"="dashed","<$50K"="dotted")) +  
  theme_bw() + mattheme + 
  theme(legend.position = c(.77, .23))

# --- Age x Amount Interaction Plot ---
# This plot visualizes how the relationship between age and discounting
# differs across the small, medium, and large loss amounts.

# 1. Create prediction grid.
pred_grid_amount <- expand(DL_dat4, Age = seq(35, 80, 1),
                           Amount = c(1, 2, 3)) |>
  # 2. Scale Age and Amount, hold other predictors at their mean.
  mutate(
    Age_std = (Age - mean(DL_dat4$Age)) / (2*sd(DL_dat4$Age)),
    Amount_std = (Amount - mean(DL_dat4$Amount)) / (2*sd(DL_dat4$Amount)),
    Income_std = 0, Education_std = 0, Gender_c = 0, 
    Anxiety_std = 0, Health_std = 0,
    Amount_Factor = factor(Amount, levels = c(1,2,3), labels = c("$150", "$2,500", "$30,000"))
  )

# 3. Generate posterior predictions.
p_amount <- add_epred_draws(DL_mod4, newdata = pred_grid_amount, re_formula = NA) |> 
  # 4. Summarize posteriors.
  group_by(Age, Amount_Factor) |> 
  summarize(.epred = median(.epred), .groups = 'drop') |>
  # 5. Build ggplot object.
  ggplot(aes(x = Age, y = .epred, group = Amount_Factor, color = Amount_Factor)) +
  geom_line(aes(linetype = Amount_Factor), size = 1) +  
  labs(x = "Age", y = "Area under the Curve", color = "Amount", linetype = "Amount") + 
  scale_y_continuous(limits = c(.198, 1.002), breaks = seq(.2,1,.2), expand = c(0,0)) +
  scale_x_continuous(limits = c(33.5,81.5), breaks = seq(35,80,15), expand = c(0,1)) +
  scale_linetype_manual(values = c("$30,000"="solid","$2,500"="dashed","$150"="dotted")) +  
  scale_color_manual(values = c("$30,000"="#1f78b4","$2,500"= "#ff7f00","$150"="#33a02c")) +
  theme_bw() + mattheme + 
  theme(legend.position = c(.77, .23))

# Arrange and display plots side-by-side using ggarrange
ggarrange(p_income, p_amount, ncol = 2, common.legend = FALSE)
```
